<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lsh::blog (Posts about java-8)</title><link>https://lyubomyr-shaydariv.github.io/</link><description></description><atom:link href="https://lyubomyr-shaydariv.github.io/categories/java-8.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:"&gt;Lyubomyr Shaydariv&lt;/a&gt; </copyright><lastBuildDate>Mon, 19 Apr 2021 08:21:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Optional&lt;T&gt; tends to be used in a wrong way</title><link>https://lyubomyr-shaydariv.github.io/posts/2017-01-26-optional-tends-to-be-used-in-a-wrong-way/</link><dc:creator>Lyubomyr Shaydariv</dc:creator><description>&lt;div&gt;&lt;p&gt;Want to explicitly declare a nullability contract?
You probably might want to use &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;, but it does not seem to be the best way.
I've got some cons against it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://lyubomyr-shaydariv.github.io/posts/2017-01-26-optional-tends-to-be-used-in-a-wrong-way/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>java</category><category>java-8</category><guid>https://lyubomyr-shaydariv.github.io/posts/2017-01-26-optional-tends-to-be-used-in-a-wrong-way/</guid><pubDate>Thu, 26 Jan 2017 00:12:00 GMT</pubDate></item><item><title>Sequential Mockito verifications refactoring with fluent interfaces</title><link>https://lyubomyr-shaydariv.github.io/posts/2016-09-23-sequential-mockito-verifications-refactoring-with-fluent-interfaces/</link><dc:creator>Lyubomyr Shaydariv</dc:creator><description>&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;This article was originally written in Russian and published on September 12, 2016 at &lt;a href="https://habrahabr.ru/post/309752/"&gt;Habrahabr&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Static methods have one powerful and not very desirable feature: they can be invoked from any place of the code, and they also can't really dictate the order of such invocations.
Usually such control is really important, but sometimes the real order does not make much sense.
For example, assertions and verifications in unit tests often do not require to be executed in strict order.
To ensure that all verifications are done, &lt;a href="http://mockito.org/"&gt;Mockito&lt;/a&gt; provides a static method named &lt;code&gt;verifyNoMoreInteractions(...)&lt;/code&gt;.
Sometimes, accidentally, this method can be invoked before the last &lt;code&gt;verify(...)&lt;/code&gt; is invoked so a bitter "red" test will be the result.
But what if delegate the verification order check to the compiler?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://lyubomyr-shaydariv.github.io/posts/2016-09-23-sequential-mockito-verifications-refactoring-with-fluent-interfaces/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>java</category><category>java-8</category><category>mockito</category><guid>https://lyubomyr-shaydariv.github.io/posts/2016-09-23-sequential-mockito-verifications-refactoring-with-fluent-interfaces/</guid><pubDate>Fri, 23 Sep 2016 15:41:00 GMT</pubDate></item><item><title>Java 8 libraries and Android applications using Maven</title><link>https://lyubomyr-shaydariv.github.io/posts/2016-08-06-java-8-libraries-and-android-applications-using-maven/</link><dc:creator>Lyubomyr Shaydariv</dc:creator><description>&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;The original question was originally posted on May 17, 2015 at &lt;a href="http://stackoverflow.com/questions/30286371/maven-using-java-8-libraries-in-applications-instrumented-with-retrolambda-mave/32510895"&gt;StackOverflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This article was originally written in Russian and published on September 15, 2015 at &lt;a href="https://habrahabr.ru/post/266881/"&gt;Habrahabr&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 8 was released in early 2014 featuring some pretty convenient new &lt;a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html"&gt;features&lt;/a&gt; to simplify trivial coding and letting the developers to simplify their lives.
Some of them are lambda expressions, method and constructor references, interface default methods as the Java language and JVM extensions, and the &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html"&gt;Stream API&lt;/a&gt; for JDK.
Unfortunately, slow introduction of such new features has a pretty negative impact on another Java-oriented platforms.
GWT and Android still lack the Java 8 language features official support.
However, the last spring GWT 2.8.0 SNAPSHOT versions have lambda expressions support already.
Android things are still different since lambda expressions rely on the Android Java runtime, and not just the compiler.
But Maven 8 lets to solve the Java 8 use problem relatively easy.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://lyubomyr-shaydariv.github.io/posts/2016-08-06-java-8-libraries-and-android-applications-using-maven/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>android</category><category>java</category><category>java-8</category><category>maven</category><category>retrolambda</category><guid>https://lyubomyr-shaydariv.github.io/posts/2016-08-06-java-8-libraries-and-android-applications-using-maven/</guid><pubDate>Sat, 06 Aug 2016 14:44:00 GMT</pubDate></item></channel></rss>